## Java指令到底干了些什么？ 我们写的java代码是如何被加载到JVM内存中执行的？
- HelloWorld.java
- javac HelloWorld.java -> .class
- java HelloWorld
# 故事内容：
回顾java类加载器。实战自定义的类加载器。实现自己的热加载。实现同类多个版本共存。
# 类加载机制
Java类加载体系：
> Bootstrap classLoader > ExtClassLoader > AppClassLoader
每个类加载器都有他自己的加载目录。
## 双亲委派机制 - 一个java类加载进JVM内存的过程
- 以自己编写的Hello.class为例 
  1. 如果AppClassLoader加载过就直接返回，不存在不会直接加载而是回去上级加载器查找
  2. 如果找不到就从 extClassLoader加载 如果extClassLoader加载过就直接返回
  3. 如果找不到就从Bootstrap类加载器加载。

* 每个类加载器对他加载过的类都有一个缓存
* 向上委托查找，向下委托加载。
**保证java基类不能被覆盖** 
3. JDK的类加载对象
```text
classloader -> SecureClassloader -> URlClassloader -> ExtClassLader,AppClassLoader
```
# 故事背景
 有一个oA系统定时计算我们的工资系统。
# 故事序幕
 有一个程序员，想要修改工资的计算方式，偷偷加工资。
 他偷偷修改了oA系统中的计算工资的方法源码，给自己加了两成的工资。
# 第一章 代码拆分
程序员偷偷加了工资，但是，肯定会被经理发现。OA系统的源码，经理也能看到
把计算工资的方法，从OA系统中抽离出来，放到其他地方。
> 这样的jar包文件可以放在哪里？放到网络地址、maven仓库
# 第二章
我们的jar包最终都可以通过反编译的方式，被发现。需要对jar包进行混淆。
第一个想法：对class文件做手脚
    修改.class的文件后缀，改为.myclass
    自定义一个类加载器，读取.myclass文件
> 怎么实现一个类加载器？ 1. 继承一个类加载器SecureClassLoader; 2. 覆盖父类的findClass方法，在方法中，调用defineClass方法在JVM内存中定义一个类。
> 
> 扩展：虽然该了文件后缀但是文件后缀没有改。
程序员可以通过简单修改二进制文件的方式，对class文件的内同做少量的修改， 这样class文件的安全性得到进一步的提升。
最终这种处理方法还是要继承到jar包中。